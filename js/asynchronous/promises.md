# Промисы (Promises)

_Promise_ (обещание) — часть стандарта _es6_ и специальная функция (`typeof Promise === 'function'`),
которую можно использовать для отложенных и асинхронных операций.

Многие современные стандарты и API имеют promise интерфейсы.

## Синтаксис

```js
const promise = new Promise(function(resolve, reject) { });

promise.then(result => { }, error => { });
// или
promise.then(result => {}).catch(error => {});
```

## Описание

Для начала, давайте определимся что Promise может находиться в трёх состояниях:

* _ожидание (pending)_ — начальное состояние, не выполнено и не отклонено;
* _выполнено (fulfilled, resolved)_ — операция завершена успешно;
* _отклонено (rejected)_ — операция завершена с ошибкой.

Итак, при создании промис находится в _ожидании (pending)_,
затем он может стать _выполненным (resolved)_ или _отклонённым (rejected)_.
В первом случае он может вернуть результат операции, а во втором ошибку (причину отказа).
В любом из этих случаев вызовется прикреплённый обработчик _then_.

_Примечания:_

* Промис может выполниться только один раз;
* Промис не может поменят свой статус выполнения;
* Промис нельзя отменить;
* Выполнение обработчика _then_ помещается в конец очереди _main thread_, примерно как `setTimeout(..,0)`;
* Обработчик _then_ выполнится в любом случае, независимо от того был он прикреплён до или после того,
  как выполнился промис (resolved или rejected).

## Цепочки

Обработчик _then_ (как и _catch_) возвращает промис,
соответственно мы можем организовать цепочку операций (синхронных или асинхронных),
например для последовательной обработки данных.

```js
promise.then(result1 => {
    // возвращаем изменённые данные
}).then(result2 => {
    // или новый промис
});
```

Если возвращать значение, оно автоматически завернётся в resolved промис,
и следующий _then_ будет вызван с этим значением.
Если же возвращать промис, то следующий _then_ дождётся выполнения этого промиса, и только потом будет вызван.

## Последовательное выполнение

Следующий пример показывает как можно использовать динамические цепочки в циклах:

```js
chapterUrls.reduce((sequence, chapterUrl) => {
    return sequence.then(function() {
        return getJSON(chapterUrl);
    }).then(function(chapter) {
        addHtmlToPage(chapter.html);
    });
}, Promise.resolve());
```

`Promise.resolve()` — выполненный промис, и начало нашей цепочки.

## Параллельное выполнение

Некоторые операции браузер может делать параллельно, например загрузку ресурсов.
С помощью промисов мы можем легко выполнить некоторый код после загрузки всех необходимых ресурсов:

```js
// arrayOfPromises = массив промисов.
// один промис = загрузка одного ресурса.
Promise.all(arrayOfPromises)
    .then(function(arrayOfResults) {
        // arrayOfResults = массив возвращенных промисами значений 
        // в том же порядке, в котором вы их передали.
    });
```

***

## Ссылки

* [Promise (MDN)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise)
* [Промисы (frontender.info)](http://frontender.info/promises/)
* [Промисы (learn.javascript.ru)](https://learn.javascript.ru/promise)
* [caniuse](http://caniuse.com/#feat=promises)
