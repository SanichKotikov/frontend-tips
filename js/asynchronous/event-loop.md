# Обзор (event loop, stack and queue)

JavaScript однопоточный! Это означает, что в одну еденицу времени выполняется что-то одно.
Нужно также понимать, что этот поток блокирует браузер (отрисовку и взаимодействие со страницей).
Поэтому большие вычесления лучше делать через `Web Worker`, у которого свой отдельный поток.

## Определения:

### Стек (stack)

Вызов функции создаёт _контекст выполнения_. Вызов вложенной функции создаёт новый контекст,
а старый сохраняется в **Стек**:

```js
function first() {
    const err = new Error();
    console.log(err.stack);
    /* =>
        at first — текущее положение
        at second
        at window.onload
    */
}

function second() {
	first();
}

second();
```

### Очередь событий (queue)

Очередь колбеков, которые будут выполнены, как только стек будет пуст.

### Куча (heap)

Неструктурированная область памяти, где хранятся объекты.

## Как это всё работает вместе?

```

----------------     -------------------
|      |       |     | WebAPIs:        |
| heap | stack | ==> | XHR, setTimeout |
|      |       |     | ...             |
----------------     -------------------
       ▲
----------------              |
|  event loop  |              ▼
----------------
       ▲
----------------------------------------
|               queue                  |
----------------------------------------

```

Что тут важно понимать:

* `WebAPIs` не блокируют основной поток (за некоторыми исключениями), и выполняются браузером отдельно.
  Как только они выполнятся, `callback` отправляется в очередь (`queue`).
* Как только `stack` освободится, `event loop` извлекает первый `callback` из очереди и помещает в стек,
  где он и выполняется.
* Как только `stack` снова освободится, `event loop` извлекает следующий `callback` и т.д.
* Если очередь пуста — `event loop` ждёт, пока в неё что ни будь попадёт.

Простой пример:

```js
console.log(1);
setTimeout(() => console.log(2), 5);
var endDate = +new Date() + 10;
while (+new Date() < endDate){
	// busy loop for 10 ms
}
console.log(3);
```

В консоль будет выведено:

```
1
3
2
```

Не смотря на таймер в `5ms`, `event loop` не может перенести _задачу_ из очереди (и выполнить её),
т.к. основной поток всё ещё занят. В итоге, таймаут выполнится не раньше, чем через `10ms`.

## Ссылки:

* [Philip Roberts: What the heck is the event loop anyway?](https://www.youtube.com/watch?v=8aGhZQkoFbQ)
